

(** {1 Convex Hull}

  MPRI course 2-36-1 Proof of Programs - Project 2022-2023

*)


(** {2 Dummy symbols to fill holes in the remainder} *)

module DummySymbols

predicate __FORMULA_TO_BE_COMPLETED__
constant __TERM_TO_BE_COMPLETED__ : 'a
constant __VARIANT_TO_BE_COMPLETED__ : int
let constant __EXPRESSION_TO_BE_COMPLETED__ : int = 0
let constant __CONDITION_TO_BE_COMPLETED__ : bool = False
let constant __FUNCTION_TO_BE_COMPLETED__ : int -> int = fun _ -> 0
let constant __CODE_TO_BE_COMPLETED__ : unit = ()

let constant __MIN_PTS_NUM__ : int = 3

end



(** {2 Points in the Plane, Sets of Points} *)

module Point

use export DummySymbols
use export real.RealInfix
use export int.Int

(** Points in the plane are records of two real numbers *)

type pt = { x : real ; y : real }

(** Sets of points, represented as arrays *)

use export array.Array

type pt_set = array pt

(** access in or outside indexes of a set *)

predicate is_index (i:int) (s:pt_set) =
  0 <= i < s.length


(** A total order on points: (x1,y1) <= (x2,y2) if
    y1 < y2 or y1 = y2 and x1 <= x2 *)

predicate is_lower_pt (p1 p2:pt) =
  p1.y <. p2.y \/ (p1.y = p2.y /\ p1.x <=. p2.x)


(** QUESTION 1: compute the lowest-leftmost pt *)

let lowest_leftmost (s:pt_set) : int
  requires { s.length > 0 }                             (* car on accède à s[0] *)
  ensures { is_index result s }                         (* le résultat doit faire parti des choix possibles*)
  ensures { forall i:int. is_index i s -> is_lower_pt s[result] s[i] } (* il s'agit bien du plus petit *)
=
  let ref r = 0 in
  let ref rp = s[0] in
  for i = 1 to s.length - 1 do
    invariant { forall j:int. 0 <= j < i -> is_lower_pt s[r] s[j] } (* postcondition jusqu'à [i] *)
    invariant { s[r] = rp }
    invariant { is_index r s }
    let p = s[i] in
    if p.y <. rp.y || (p.y =. rp.y && p.x <=. rp.x) then
      begin
        r <- i;
        rp <- p;
      end
  done;
  r


end





(** {2 Specification of the counter-clockwise predicate} *)

module CCW

use Point

(** The ccw predicate *)

function crossproduct (p1 p2 p3:pt) : real =
  (p2.x -. p1.x) *. (p3.y -. p1.y) -. (p3.x -. p1.x) *. (p2.y -. p1.y)

predicate colinear (p1 p2 p3:pt) =
  crossproduct p1 p2 p3 = 0.0

predicate ccw (p1 p2 p3:pt) =
  crossproduct p1 p2 p3 >. 0.0

predicate ccw_neg (p1 p2 p3:pt) =
  crossproduct p1 p2 p3 <. 0.0

val ccw (p1 p2 p3:pt) : bool
  ensures { result <-> ccw p1 p2 p3 }

val ccw_neg (p1 p2 p3:pt) : bool
  ensures { result <-> ccw_neg p1 p2 p3 }

lemma knuth1:
  forall p1 p2 p3:pt. ccw p1 p2 p3 -> ccw p2 p3 p1

lemma knuth2:
  forall p1 p2 p3:pt. ccw p1 p2 p3 -> not (ccw p2 p1 p3)

lemma knuth3:
  forall p1 p2 p3:pt.
   not (colinear p1 p2 p3) -> ccw p1 p2 p3 \/ ccw p1 p3 p2

lemma knuth4:
  forall p1 p2 p3 q:pt.
    ccw q p1 p2 ->
    ccw q p2 p3 ->
    ccw q p3 p1 ->
    ccw p1 p2 p3

(* TODO : le lemme ne passe pas *)
axiom cramer:
  forall p1 p2 p3 q1 q2:pt.
    crossproduct q1 q2 p3 *. crossproduct q2 p1 p2 +.
    crossproduct q1 q2 p1 *. crossproduct q2 p2 p3 =
    crossproduct q1 q2 p2 *. crossproduct q2 p1 p3

lemma knuth5_aux:
  forall p1 p2 p3 q1 q2:pt.
    ccw q1 q2 p1 /\ ccw q2 p2 p3 /\ ccw q1 q2 p3 /\ ccw q2 p1 p2 ->
    crossproduct q1 q2 p2 *. crossproduct q2 p1 p3 >. 0.0 &&
    (crossproduct q1 q2 p2 >. 0.0 -> crossproduct q2 p1 p3 >. 0.0)

lemma knuth5:
  forall p1 p2 p3 q1 q2:pt.
    ccw q1 q2 p1 /\ ccw q1 q2 p2 /\ ccw q1 q2 p3 ->
    ccw q2 p1 p2 /\ ccw q2 p2 p3 -> ccw q2 p1 p3



(* QUESTION 2 *)

let function diff2 (k i j: int) : bool
= k <> i && k <> j

(** (all_on_left s i j) is true when all points in s, except points at
    index i and j themselves, are on the left of the vector s[i] s[j]
    *)

(* pour tout k dans len(s), s[k] est à gauche de s[i]-s[j] si le ccw est correct *)
predicate all_on_left (s:pt_set) (i j:int) =
  forall k : int.
    is_index k s ->
    diff2 k i j ->
    ccw s[i] s[j] s[k]

(* QUESTION 3 *)

exception Exit

let check_all_on_left (s:pt_set) (i j:int) : unit
  requires { is_index i s }                          (* acces [s[i]] *)
  requires { is_index j s }                          (* idem [j] *)
  ensures  { all_on_left s i j }                     (* sujet *)
  raises   { Exit -> not (all_on_left s i j) }       (* postcondition exceptionnelle *)
=
  let a = s[i] in let b = s[j] in
  for k = 0 to s.length - 1 do
    invariant { forall l: int. 0 <= l < k -> diff2 l i j -> ccw a b s[l] } (* tous les points passés sont bien à gauche de a-b *)
    invariant { 0 <= k < s.length - 1 -> diff2 k i j -> not ccw a b s[k] -> not all_on_left s i j } (* permet de prouver la postcondition exceptionnelle : si le if est faux alors la postcondition est vraie *)
    if diff2 k i j && not ccw a b s[k] then raise Exit
  done

predicate is_on_left (s: pt_set) (i j k: int) =
  is_index i s ->
  is_index j s ->
  is_index k s ->
  ccw s[i] s[j] s[k]

predicate is_on_right (s: pt_set) (i j k: int) =
  is_index i s ->
  is_index j s ->
  is_index k s ->
  ccw s[i] s[k] s[j]

end

(** {2 Module for Paths} *)

module Path

  use int.Int

  type path = {
    mutable size : int;
    ghost mutable elements : int -> int
  }

  predicate is_valid_index (i:int) (p:path) =
    0 <= i < p.size

  predicate contains (p: path) (elt: int) =
    exists i: int. is_valid_index i p /\ p.elements i = elt

  val create () : path
    ensures { result.size = 0 }

  val nth (p: path) (i: int) : int
    requires { is_valid_index i p }
    reads    { p }
    ensures  { result = p.elements i }

  val append (p:path) (v: int) : unit
    writes  { p }
    ensures { p.size = (old p.size) + 1 }
    ensures { p.elements (old p.size) = v }
    ensures { forall i. 0 <= i < (old p.size) -> p.elements i = (old p.elements) i }

end


module ConvexHull

use Point
use CCW
use Path

let function nth = Path.nth
(* let function last = Path.last *)

(* use export array.NumOfEq
    (* numof s (nth p i) > 0 *) *)

let function distinct (p:path) : bool
  ensures { result <->
    forall i j:int.
      is_valid_index i p ->
      is_valid_index j p ->
      i < j ->
      p.elements i <> p.elements j }
= try
    for i = 0 to p.size - 1 do
    invariant { forall k l: int. 0 <= k < l < i -> p.elements k <> p.elements l }
    for j = 0 to i - 1 do
    invariant { forall k: int. 0 <= k < j -> p.elements k <> p.elements i }
      if nth p i = nth p j then raise Exit
    done
    done;
    True
  with Exit -> False
  end

(* QUESTION 4 *)

(* - les indices du path [p] sont bien des indices de [s]
   - les éléments de [p] sont bien différents deux à deux *)
let function wf_path (p:path) (s:pt_set)
  ensures { result <->
    distinct p /\
    forall i: int. is_valid_index i p -> is_index (nth p i) s }
= if not distinct p then False else
  try
    for i = 0 to p.size - 1 do
      invariant { forall j: int. 0 <= j < i -> is_index (nth p j) s }
      let a = nth p i in
      if a < 0 || a >= s.length then raise Exit
    done;
    True
  with Exit -> False
  end

let function plus1mod (i len: int): int
= if i + 1 = len then 0 else i+1

predicate is_convex_hull (s:pt_set) (p:path)
= wf_path p s /\
  (s.length >= __MIN_PTS_NUM__ -> (* si moins de 2 alors pas de segment dont on doit être à gauche *)
   forall i: int. is_valid_index i p ->
    let j = plus1mod i p.size in
    all_on_left s (nth p i) (nth p j))

(* let lemma xx2 (s: pt_set) (p: path) : unit
  requires { is_convex_hull s p }
  ensures  { wf_path p s }
= ()

let lemma xx (s: pt_set) (p: path) : unit
  requires { not wf_path p s }
  ensures  { not is_convex_hull s p }
= () *)

(* QUESTION 5 *)

let check_is_convex_hull (s:pt_set) (p:path) : bool
  requires { s.length >= __MIN_PTS_NUM__ }             (* condition de taille sur [s] *)
  requires { p.size >= __MIN_PTS_NUM__ }               (* condition de taille sur [s] *)
  (* requires { wf_path p s }                             (* *) *)
  ensures { result = True <-> is_convex_hull s p }
=
  if not wf_path p s then False else
  try
    assert { wf_path p s };
    for i = 0 to p.size - 1 do
      invariant { forall j: int. 0 <= j < i -> all_on_left s (nth p j) (nth p (plus1mod j p.size)) }
      invariant { forall j: int. 0 <= j < i -> is_valid_index j p }
      let j = plus1mod i p.size in
      let a = nth p i in
      let b = nth p j in
      check_all_on_left s a b
    done;
    True
  with Exit -> False
  end


(** Properties assumed to characterize "general" set of points *)

predicate no_colinear_triple (s:pt_set) =
  forall i j k:int. is_index i s /\ is_index j s /\ is_index k s /\
    i <> j /\ i <> k /\ j <> k -> not (colinear s[i] s[j] s[k])

predicate unique_minimal_y (s:pt_set) (i:int) =
  is_index i s /\
    forall j:int. is_index j s /\ i <> j -> s[i].y <. s[j].y


(** QUESTION 7 : the largest function (see QUESTION 6 later) *)


(** extract the largest point `p` among set `s` for the relation

      R(p1,p2) := ccw pivot p1 p2

   All points are assumed to be on the left of the segment (base,pivot) *)

let function largest (s: pt_set) (pivot: int) (ghost base: pt): int
  requires { no_colinear_triple s }
  requires { length s >= __MIN_PTS_NUM__ }
  requires { is_index pivot s }
  requires {
    forall k : int. is_index k s ->
      k <> pivot ->
      s[k] <> base ->
      ccw base s[pivot] s[k] } (* all on left base-pivot *)
  ensures {
    forall k: int. is_index k s ->
    diff2 k pivot result ->
    ccw s[pivot] s[result] s[k] }
  ensures { is_index result s }
  ensures { result <> pivot }
  (* ensures { result = hd
            \/ not contains p result } *)
  (* ensures { result <> base } *)
=
  let ref res = if pivot = 0 then 1 else 0 in
  let ghost res_init = if pivot = 0 then 1 else 0 in
  for i = res+1 to s.length - 1 do
    invariant { is_index res s }
    invariant { i > 0 -> is_index (i-1) s }
    invariant {
      forall j: int. res_init+1 <= j < i - 1 ->
      j <> pivot ->
      ccw s[pivot] s[res_init] s[j]
    }
    if i <> pivot then
      if ccw s[pivot] s[i] s[res] then
           res <- i;
  done;
  res


(** QUESTION 6: Jarvis, not proving termination *)

function translate_left (p:pt) : pt =
  { x = p.x -. 1.0 ; y = p.y }

let jarvis_no_termination (s:pt_set) : path
  requires { no_colinear_triple s }
  requires { exists i: int. unique_minimal_y s i }
  requires { length s >= __MIN_PTS_NUM__ }
  diverges
  ensures { is_convex_hull s result }
=
  let hd = lowest_leftmost s in
  let p = create () in
  append p hd;
  let ghost base = translate_left s[hd] in
  let next = largest s hd base in
  append p next;
  let ref oldpivot = hd in
  let ref pivot = next in
  try
    while True do
      invariant { p.size > 0 }
      invariant { pivot <> hd }
      invariant { is_index pivot s }
      invariant { is_index oldpivot s }
      invariant { nth p (p.size - 1) = pivot }
      invariant { nth p (p.size - 2) = oldpivot }
      invariant { all_on_left s oldpivot pivot }
      invariant {
        forall t: int. 1 <= t < p.size ->
          all_on_left s (nth p (t-1)) (nth p t)
      }

      invariant { forall i:int. 0 < i < p.size - 1 -> nth p i = pivot ->
        let elt = nth p (i-1) in
        diff2 elt pivot oldpivot ->
          ccw s[oldpivot] s[pivot] s[elt] /\
          ccw s[pivot] s[elt] s[oldpivot] /\
          ccw s[elt] s[oldpivot] s[pivot] /\
          not ccw s[elt] s[pivot] s[oldpivot] /\
          ccw s[elt] s[oldpivot] s[pivot] /\
          ccw s[elt] s[nth p i] s[oldpivot] }
      invariant { forall i:int. 0 < i < p.size - 1 -> nth p i <> pivot }
      invariant { nth p 0 = hd }
      invariant { nth p 0 <> pivot }
      invariant { forall i:int. 0 <= i < p.size - 1 -> nth p i <> pivot }

      (* invariant { forall i:int. 0 <= i < p.size - 1 -> nth p i <> (nth p (p.size - 1)) } *)
      invariant { forall i j:int. 0 <= i < p.size -> 0 <= j < p.size -> i <> j -> nth p i <> nth p j }

      invariant { wf_path p s } (* problème sur distinct *)
      let next = largest s pivot s[oldpivot] in
      (* assert { next = hd \/ not contains p next }; *)
      if next = hd then raise Exit;
      (* assert { contains p next -> is_on_right s pivot next hd }; *)
      (* assert { contains p next -> not all_on_left s pivot next }; *)
      oldpivot <- pivot;
      pivot <- next;
      (* assert { not contains p next }; *)
      append p next;
    done;
    absurd
  with Exit -> p
  end


(** QUESTION 8: termination *)

(* A suggested ghost function *)

predicate range (f: int -> int) (n: int) (m:int) =
    forall i: int. 0 <= i < n -> 0 <= f i < m
  (** `range f n m` is true when `f` maps the domain
      `(0..n-1)` into `(0..m-1)` *)

predicate injective (f: int -> int) (n: int) =
    forall i j: int. 0 <= i < j < n -> f i <> f j
  (** `injective f n m` is true when `f` is an injection
      from `(0..n-1)` to `(0..m-1)` *)

let rec ghost inverse (l:int) (f:int -> int) (v:int) : int
  requires { l >= 1 }
  requires { range f l l }
  requires { injective f l }
  requires { 0 <= v < l }
  variant { l }
  ensures { 0 <= result < l /\ v = f result }
= 0 (* code/proof to be completed *)



let jarvis (s:pt_set) : path
  requires { __FORMULA_TO_BE_COMPLETED__ }
  ensures { is_convex_hull s result }
=
  let hd = lowest_leftmost s in
  let p = create () in
  append p hd;
  let ghost ref base = translate_left (s[hd]) in
  let next = largest s hd base in
  append p next;
  let ref oldpivot = hd in
  let ref pivot = next in
  try
    while True do
      invariant { __FORMULA_TO_BE_COMPLETED__      }
      variant { __VARIANT_TO_BE_COMPLETED__ }
      let next = largest s pivot s[oldpivot] in
      if next = hd then raise Exit;
      oldpivot <- pivot;
      pivot <- next;
      append p next;
    done;
    absurd
  with Exit ->
    p
  end





end
